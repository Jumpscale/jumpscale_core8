import re
import collections
from jinja2 import Template
from github.GithubObject import NotSet

from JumpScale import j


MILESTONE_REPORT_FILE = 'milestone-report.md'
ASSIGNEE_REPORT_FILE = 'assignee-report.md'

MILESTONE_REPORT_TMP = Template('''\
> This file is auto generated by `ays` services. Please don't modify manually.

# Summary
|Milestone|ETA|
|---------|---|
{% for milestone in milestones.values() -%}
|[{{ milestone.title }}](#milestone-{{ milestone.title | replace(' ', '-')| replace('.', '')| lower }})|{{ summary(milestone.title) }}|
{% endfor -%}
|[No milestone](#no-milestone)|{{ summary('__no_milestone__') }}|

{% for key, milestone in milestones.items() -%}
## [Milestone {{ milestone.title }}](milestones/{{ key }}.md)

{% set issues = report.get(milestone.title, []) %}
|Issue|Title|State|Owner|ETA|
|-----|-----|-----|-----|---|
{% for issue in issues -%}
|[#{{ issue.number }}](https://github.com/{{ repo.fullname }}/issues/{{ issue.number }})|\
{{ issue.title }}|\
{{ state(issue.state) }}|\
{% if issue.assignee %}[{{ issue.assignee }}](https://github.com/{{ issue.assignee }}){% endif %}|\
{% set eta, id = estimate(issue) %}{% if eta %}[{{ eta|trim }}]({{ issue.url }}#issuecomment-{{ id }}){% else %}N/A{% endif %}|
{% endfor %}
{% endfor %}


## No milestone
|Issue|Title|State|Owner|ETA|
|-----|-----|-----|-----|---|
{% for issue in report.get('__no_milestone__', []) -%}
|[#{{ issue.number }}](https://github.com/{{ repo.fullname }}/issues/{{ issue.number }})|\
{{ issue.title }}|\
{{ state(issue.state) }}|\
{% if issue.assignee %}[{{ issue.assignee }}](https://github.com/{{ issue.assignee }}){% endif %}|\
{% set eta, id = estimate(issue) %}{% if eta %}[{{ eta|trim }}]({{ issue.url }}#issuecomment-{{ id }}){% else %}N/A{% endif %}|
{% endfor %}
''')

MILESTONE_DETAILS_TEMP = Template('''\
> This file is auto generated by `ays` services. Please don't modify manually.

# Milestone {{milestone.title}}

## List of all unassigned issues in this milestone

|Issue|Title|State|Type|
|-----|-----|-----|---|
{% for issue in issues -%}
{% if issue.milestone == key and not issue.assignee and issue.isOpen -%}
|[#{{ issue.number }}](https://github.com/{{ repo.fullname }}/issues/{{ issue.number }})|\
{{ issue.title }}|\
{{ state(issue.state) }}|\
{{ issue.type }}|
{% endif -%}
{% endfor %}

## Issues per assignee
{% for user, issues in assignees.items() -%}
- [{{ user }}](#{{ user|replace(' ', '-')|replace('.', '')|lower }})
{% endfor %}

{% for user, issues in assignees.items() %}
### [{{ user }}](https://github.com/{{user}})

|Issue|Title|State|Type|
|-----|-----|-----|----|
{% for issue in issues -%}
{% if issue.milestone == key -%}
|[#{{ issue.number }}](https://github.com/{{ repo.fullname }}/issues/{{ issue.number }})|\
{{ issue.title }}|\
{{ state(issue.state) }}|\
{{ issue.type }}|
{% endif -%}
{% endfor %}
{% endfor %}
''')

ASSIGNEE_REPORT_TMP = Template('''\
> This file is auto generated by `ays` services. Please don't modify manually.

# Issues per assignee
{% for user, issues in assignees.items() -%}
- [{{ user }}](#{{ user|replace(' ', '-')|replace('.', '')|lower }}) has {{ issues|count }} assigned
{% endfor %}

{% for user, issues in assignees.items() %}
## [{{ user }}](https://github.com/{{user}})

|Issue|Title|State|Type|
|-----|-----|-----|----|
{% for issue in issues -%}
|[#{{ issue.number }}](https://github.com/{{ repo.fullname }}/issues/{{ issue.number }})|\
{{ issue.title }}|\
{{ state(issue.state) }}|\
{{ issue.type }}|
{% endfor %}
{% endfor %}
''')

re_story_name = re.compile('.+\((.+)\)\s*$')
re_task_estimate = re.compile('.+\[([^\]]+)\]\s*$')
re_story_estimate = re.compile('^ETA:\s*(.+)\s*$', re.MULTILINE)


class Github(object):
    def __init__(self):
        self.__jslocation__ = "j.tools.github"
        self.logger = j.logger.get('j.tools.github')

    def _story_name(self, title):
        m = re_story_name.match(title.strip())
        if m is None:
            return None

        return m.group(1)

    def _story_tasks(self, name, issues):
        tasks = []
        for issue in issues:
            story = issue.title.partition(':')[0].strip()
            if story == name:
                tasks.append(issue)
        return tasks

    def _task_estimate(self, title):
        m = re_task_estimate.match(title)
        if m is not None:
            return m.group(1).strip()
        return None

    def _story_estimate(self, issue):
        comments = issue.comments
        if not len(comments):
            return None, None
        # find last comment with ETA
        for last in reversed(comments):
            m = re_story_estimate.search(last['body'])
            if m is not None:
                return m.group(1), last['id']
        return None, None

    def _process_stories(self, issues):
        #make sure all stories are auto labeled correctly
        stories = dict()

        for issue in issues:
            if issue.repo.type not in ['home', 'proj', 'milestone', 'org']:
                continue

            story_name = self._story_name(issue.title)
            if story_name is not None:
                stories[story_name] = issue
                if issue.type != 'story':
                    issue.type = 'story'

        return stories

    def _move_to_repo(self, issue, dest):
        self.logger.info("%s: move to repo:%s" % (issue, dest))
        ref = 'https://github.com/%s/issues/%s' % (issue.repo.fullname, issue.number)
        body = "Issue moved from %s\n\n" % ref

        for line in issue.api.body.splitlines():
            if line.startswith("!!") or line.startswith(
                    '### Tasks:') or line.startswith('### Part of Story'):
                continue
            body += "%s\n" % line

        assignee = issue.api.assignee if issue.api.assignee else NotSet
        labels = issue.api.labels if issue.api.labels else NotSet
        moved_issue = dest.api.create_issue(title=issue.title, body=body,
                                            assignee=assignee, labels=labels)
        moved_issue.create_comment(self._create_comments_backlog(issue))
        moved_ref = 'https://github.com/%s/issues/%s' % (dest.fullname, moved_issue.number)
        issue.api.create_comment("Moved to %s" % moved_ref)
        issue.api.edit(state='close')  # we shouldn't process todos from closed issues.

    def _create_comments_backlog(self, issue):
        out = "### backlog comments of '%s' (%s)\n\n" % (issue.title, issue.url)

        for comment in issue.api.get_comments():
            if comment.body.find("!! move") != -1:
                continue
            date = j.data.time.any2HRDateTime(
                [comment.last_modified, comment.created_at])
            out += "from @%s at %s\n" % (comment.user.login, date)
            out += comment.body + "\n\n"
            out += "---\n\n"
        return out

    def _process_todos(self, repo, issues):
        priorities_map = {
            'crit': 'critical',
            'mino': 'minor',
            'norm': 'normal',
            'urge': 'urgent',
        }

        client = repo.client

        for issue in issues:
            #only process open issues.
            if not issue.isOpen:
                continue

            for todo in issue.todo:
                cmd, _, args = todo.partition(' ')

                if not args:
                    # it seems all commands requires arguments
                    self.logger.warning("cannot process todo for %s" % (todo,))
                    continue

                if cmd == 'move':
                    destination_repo = client.getRepo(args)
                    self._move_to_repo(issue, destination_repo)
                    story_name = self._story_name(issue.title)
                    if story_name is not None:
                        for task in self._story_tasks(story_name, issues):
                            self._move_to_repo(task, destination_repo)

                elif cmd == 'p' or cmd == 'prio':
                    if len(args) == 4:
                        prio = priorities_map[args]
                    else:
                        prio = args

                    if prio not in priorities_map.values():
                        # Try to set
                        self.logger.warning(
                            'Try to set an non supported priority : %s' % prio)
                        continue

                    prio = "priority_%s" % prio
                    if prio not in issue.labels:
                        labels = issue.labels
                        labels.append(prio)
                        issue.labels = labels
                else:
                    self.logger.warning("command %s not supported" % cmd)

    def _is_story(self, issue):
        return issue.type == 'story' or self._story_name(issue.title) is not None


    def _story_add_tasks(self, story, tasks):
        """
        If this issue is a story, add a link to a subtasks
        """

        if not self._is_story(story):
            j.exceptions.Input("This issue is not a story")
            return

        def state(s):
            s = s.lower()
            if s == 'closed':
                return 'x'
            else:
                return ' '

        doc = j.data.markdown.getDocument(story.body)
        # remove all list items that start with - [
        for item in reversed(doc.items):
            if item.type != 'list':
                break
            if item.text.startswith('- ['):
                doc.items.pop()

        for task in tasks:
            line = '- [%s] %s #%s' % (state(task.state), task.title, task.number)
            doc.addMDListItem(0, line)

        # drop the table for backward compatibility
        for item in doc.items:
            if item.type == 'table':
                doc.items.remove(item)
                break

        body = str(doc)

        if body != story.body:
            story.api.edit(body=body)

    def _task_link_to_story(self, story, task):
        """
        If this issue is a task from a story, add link in to the story in the description
        """

        body = task.body
        if body is None:
            body = ''

        doc = j.data.markdown.getDocument(body)

        change = False
        header = None
        for item in doc.items:
            if item.type == 'header' and item.level == 3 and item.title.find("Part of Story") != -1:
                header = item
                break

        if header is not None:
            title = 'Part of Story: #%s' % story.number
            if title != header.title:
                header.title = title
                change = True
        else:
            change = True
            doc.addMDHeader(3, 'Part of Story: #%s' % story.number)
            # make sure it's on the first line of the comment
            title = doc.items.pop(-1)
            doc.items.insert(0, title)

        if change:
            self.logger.info("%s: link to story:%s" % (task, story))
            task.body = str(doc)

    def process_issues(self, repo, issues=None):
        """
        Process issues will find all the issues in the repo and label them accordin to the
        detected type (story, or task) add the proper linking of tasks to their parent stories, and
        adds a nice table in the story to list all story tasks.

        The tool, will also generate and commit some reports (in markdown syntax) with milestones, open stories
        assignees and estimates.

        It will also process the todo's comments

        !! prio $prio  ($prio is checked on first 4 letters, e.g. critical, or crit matches same)
        !! p $prio (alias above)

        !! move gig-projects/home (move issue to this project, try to keep milestones, labels, ...)
        """
        if issues is None:
            issues = repo.issues

        stories = self._process_stories(issues)


        issues = sorted(issues, key=lambda i: i.number)

        org_repo = False
         # Logic after this point is only for home and org repo
        for typ in ['org_', 'proj_']:
            if not repo.name.lower().startswith(typ):
                org_repo = True
                break

        _ms = [('{m.number}:{m.title}'.format(m=m), m) for m in repo.milestones]
        milestones = collections.OrderedDict(sorted(_ms, key=lambda i: i[1].title))
        report = dict()

        self._process_todos(repo, issues)

        if not org_repo:
            return

        stories_tasks = dict()
        for issue in issues:
            # Logic after this point is only for home and org repo
            if not org_repo:
                continue

            if self._is_story(issue) and issue.isOpen:
                key = '__no_milestone__'
                if issue.milestone:
                    ms = milestones.get(issue.milestone, None)
                    if ms is not None:
                        key = ms.title

                report.setdefault(key, [])
                report[key].append(issue)

            start = issue.title.partition(":")[0].strip()
            if start not in stories:
                # task that doesn't belong to any story. We skip for now
                # but i believe a different logic should be implemented
                continue

            story = stories[start]
            labels = issue.labels
            labels_dirty = False

            if "type_task" not in labels:
                labels.append("type_task")
                labels_dirty = True

            if self._task_estimate(issue.title) is None:
                if "task_no_estimation" not in labels:
                    labels.append("task_no_estimation")
                    labels_dirty = True
            else:
                # pop label out
                if "task_no_estimation" in labels:
                    labels.remove("task_no_estimation")
                    labels_dirty = True

            if labels_dirty:
                # Only update labels if it was changed.
                self.logger.debug('setting issue label')
                issue.labels = labels

            # create link between story and tasks
            # linking logic
            self._task_link_to_story(story, issue)
            tasks = stories_tasks.setdefault(story, [])
            tasks.append(issue)

        # update story links
        for story, tasks in stories_tasks.items():
            self._story_add_tasks(story, tasks)

        self._generate_views(repo, milestones, issues, report)

    def _generate_views(self, repo, milestones, issues, report):
        # end for
        # process milestones
        def _story_deadline(issue):
            eta, id = self._story_estimate(issue)
            try:
                return j.data.time.getEpochFuture(eta), id
            except:
                pass
            try:
                return j.data.time.any2epoch(eta), id
            except:
                pass

            return 0, id

        def summary(ms):
            issues = report.get(ms, [])
            ts = 0
            for issue in issues:
                eta_stamp, _ = _story_deadline(issue)
                if eta_stamp > ts:
                    ts = eta_stamp

            if ts:
                return j.data.time.epoch2HRDate(ts)
            else:
                return 'N/A'

        def state(s):
            if s == 'verification':
                return ':white_circle: Verification'
            elif s == 'inprogress':
                return ':large_blue_circle: In Progress'
            else:
                return ':red_circle: Open'

        def estimate(issue):
            eta, id = _story_deadline(issue)
            if eta:
                return j.data.time.epoch2HRDate(eta), id
            return None, None

        view = MILESTONE_REPORT_TMP.render(repo=repo, report=report, milestones=milestones,
                                           summary=summary, state=state, estimate=estimate)

        repo.set_file(MILESTONE_REPORT_FILE, view)

        # group per user
        assignees = dict()
        for issue in issues:
            if not issue.assignee or not issue.isOpen:
                continue

            assignees.setdefault(issue.assignee, [])
            assignees[issue.assignee].append(issue)

        # sort the assignees dict.
        assignees = collections.OrderedDict(sorted([(k, v) for k, v in assignees.items()], key=lambda i: i[0]))

        # generate milestone details page
        for key, milestone in milestones.items():
            view = MILESTONE_DETAILS_TEMP.render(repo=repo, key=key, milestone=milestone,
                                                 issues=issues, assignees=assignees, state=state)
            repo.set_file("milestones/%s.md" % key, view)

        # assignee details page
        view = ASSIGNEE_REPORT_TMP.render(repo=repo, assignees=assignees, state=state)
        repo.set_file(ASSIGNEE_REPORT_FILE, view)
