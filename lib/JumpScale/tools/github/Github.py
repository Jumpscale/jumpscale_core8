import re
import collections
from jinja2 import Template

from JumpScale import j


MILESTONE_REPORT_FILE = 'milestone-report.md'
ASSIGNEE_REPORT_FILE = 'assignee-report.md'

MILESTONE_REPORT_TMP = Template('''\
> This file is auto generated by `ays` services. Please don't modify manually.

# Summary
|Milestone|ETA|
|---------|---|
{% for milestone in milestones.values() -%}
|[{{ milestone.title }}](#milestone-{{ milestone.title | replace(' ', '-')| replace('.', '')| lower }})|{{ summary(milestone.title) }}|
{% endfor -%}
|[No milestone](#no-milestone)|{{ summary('__no_milestone__') }}|

{% for key, milestone in milestones.items() -%}
## [Milestone {{ milestone.title }}](milestones/{{ key }}.md)

{% set issues = report.get(milestone.title, []) %}
|Issue|Title|State|Owner|ETA|
|-----|-----|-----|-----|---|
{% for issue in issues -%}
|[#{{ issue.number }}](https://github.com/{{ repo.fullname }}/issues/{{ issue.number }})|\
{{ issue.title }}|\
{{ state(issue.state) }}|\
{% if issue.assignee %}[{{ issue.assignee }}](https://github.com/{{ issue.assignee }}){% endif %}|\
{% set eta, id = estimate(issue) %}{% if eta %}[{{ eta|trim }}]({{ issue.url }}#issuecomment-{{ id }}){% else %}N/A{% endif %}|
{% endfor %}
{% endfor %}


## No milestone
|Issue|Title|State|Owner|ETA|
|-----|-----|-----|-----|---|
{% for issue in report.get('__no_milestone__', []) -%}
|[#{{ issue.number }}](https://github.com/{{ repo.fullname }}/issues/{{ issue.number }})|\
{{ issue.title }}|\
{{ state(issue.state) }}|\
{% if issue.assignee %}[{{ issue.assignee }}](https://github.com/{{ issue.assignee }}){% endif %}|\
{% set eta, id = estimate(issue) %}{% if eta %}[{{ eta|trim }}]({{ issue.url }}#issuecomment-{{ id }}){% else %}N/A{% endif %}|
{% endfor %}
''')

MILESTONE_DETAILS_TEMP = Template('''\
> This file is auto generated by `ays` services. Please don't modify manually.

# Milestone {{milestone.title}}

## List of all unassigned issues in this milestone

|Issue|Title|State|Type|
|-----|-----|-----|---|
{% for issue in issues -%}
{% if issue.milestone == key and not issue.assignee and issue.isOpen -%}
|[#{{ issue.number }}](https://github.com/{{ repo.fullname }}/issues/{{ issue.number }})|\
{{ issue.title }}|\
{{ state(issue.state) }}|\
{{ issue.type }}|
{% endif -%}
{% endfor %}

## Issues per assignee
{% for user, issues in assignees.items() -%}
- [{{ user }}](#{{ user|replace(' ', '-')|replace('.', '')|lower }})
{% endfor %}

{% for user, issues in assignees.items() %}
### [{{ user }}](https://github.com/{{user}})

|Issue|Title|State|Type|
|-----|-----|-----|----|
{% for issue in issues -%}
{% if issue.milestone == key -%}
|[#{{ issue.number }}](https://github.com/{{ repo.fullname }}/issues/{{ issue.number }})|\
{{ issue.title }}|\
{{ state(issue.state) }}|\
{{ issue.type }}|
{% endif -%}
{% endfor %}
{% endfor %}
''')

ASSIGNEE_REPORT_TMP = Template('''\
> This file is auto generated by `ays` services. Please don't modify manually.

# Issues per assignee
{% for user, issues in assignees.items() -%}
- [{{ user }}](#{{ user|replace(' ', '-')|replace('.', '')|lower }}) has {{ issues|count }} assigned
{% endfor %}

{% for user, issues in assignees.items() %}
## [{{ user }}](https://github.com/{{user}})

|Issue|Title|State|Type|
|-----|-----|-----|----|
{% for issue in issues -%}
|[#{{ issue.number }}](https://github.com/{{ repo.fullname }}/issues/{{ issue.number }})|\
{{ issue.title }}|\
{{ state(issue.state) }}|\
{{ issue.type }}|
{% endfor %}
{% endfor %}
''')

re_story_name = re.compile('.+\((.+)\)\s*$')
re_task_estimate = re.compile('.+\[([^\]]+)\]\s*$')
re_story_estimate = re.compile('^ETA:\s*(.+)\s*$', re.MULTILINE)


class Github(object):
    def __init__(self):
        self.__jslocation__ = "j.tools.github"
        self.logger = j.logger.get('j.tools.github')

    def _story_name(self, title):
        m = re_story_name.match(title.strip())
        if m is None:
            return None

        return m.group(1)

    def _task_estimate(self, title):
        m = re_task_estimate.match(title)
        if m is not None:
            return m.group(1).strip()
        return None

    def _story_estimate(self, issue):
        comments = issue.comments
        if not len(comments):
            return None, None
        # find last comment with ETA
        for last in reversed(comments):
            m = re_story_estimate.search(last['body'])
            if m is not None:
                return m.group(1), last['id']
        return None, None

    def _process_stories(self, issues):
        #make sure all stories are auto labeled correctly
        stories = dict()

        for issue in issues:
            if issue.repo.type not in ['home', 'proj', 'milestone', 'org']:
                continue

            story_name = self._story_name(issue.title)
            if story_name is not None and issue.type != 'story':
                issue.type = 'story'
                stories[story_name] = issue

        return stories

    def _process_todos(self, issue):
        priorities_map = {
            'crit': 'critical',
            'mino': 'minor',
            'norm': 'normal',
            'urge': 'urgent',
        }

        for todo in issue.todo:
            cmd, _, args = todo.partition(' ')

            if not args:
                # it seems all commands requires arguments
                self.logger.warning("cannot process todo for %s" % (todo,))
                continue

            if cmd == 'move':
                destination_repo = self.client.getRepo(args)
                issue.move_to_repo(repo=destination_repo)
                if issue.isStory:
                    for task in issue.tasks:
                        task.move_to_repo(repo=destination_repo)

            elif cmd == 'p' or cmd == 'prio':
                if len(args) == 4:
                    prio = priorities_map[args]
                else:
                    prio = args

                if prio not in priorities_map.values():
                    # Try to set
                    self.logger.warning(
                        'Try to set an non supported priority : %s' % prio)
                    continue

                prio = "priority_%s" % prio
                if prio not in issue.labels:
                    labels = issue.labels
                    labels.append(prio)
                    issue.labels = labels
            else:
                self.logger.warning("command %s not supported" % cmd)

    def _is_story(self, issue):
        return issue.type == 'story'


    def _story_add_task(self, story, task):
        """
        If this issue is a story, add a link to a subtasks
        """

        if not self._is_story(story):
            j.exceptions.Input("This issue is not a story")
            return

        def state(s):
            s = s.lower()
            if s == 'verification':
                return ':white_circle: Verification'
            elif s == 'inprogress':
                return ':large_blue_circle: In Progress'
            elif s == 'closed':
                return ':white_check_mark: Closed'
            else:
                return ':red_circle: Open'

        change = False
        doc = j.data.markdown.getDocument(story.body)

        table = None
        for item in doc.items:
            if item.type == 'table':
                table = item
                break

        if table is not None:
            rows = filter(lambda r: r[2] == '#%s' % task.number, table.rows)
            if rows:
                row = rows[0]
                current_state = state('open') if task.isOpen else state('closed')
                if row[0] != current_state or row[1] != task.title:
                    row[0] = current_state
                    row[1] = task.title
                    change = True
            else:
                table.addRow([state(task.state), task.title, '#%s' % task.number])
                change = True
        else:
            change = True
            table = doc.addMDTable()
            table.addHeader(['status', 'title', 'link'])
            table.addRow([state(task.state), task.title, "#%s" % task.number])

        if change:
            story.api.edit(body=str(doc))

    def _task_link_to_story(self, story, task):
        """
        If this issue is a task from a story, add link in to the story in the description
        """

        body = task.body
        if body is None:
            body = ''

        doc = j.data.markdown.getDocument(body)

        change = False
        header = None
        for item in doc.items:
            if item.type == 'header' and item.level == 3 and item.title.find("Part of Story") != -1:
                header = item
                break

        if header is not None:
            title = 'Part of Story: #%s' % story.number
            if title != header.title:
                header.title = title
                change = True
        else:
            change = True
            doc.addMDHeader(3, 'Part of Story: #%s' % story.number)
            # make sure it's on the first line of the comment
            title = doc.items.pop(-1)
            doc.items.insert(0, title)

        if change:
            self.logger.info("%s: link to story:%s" % (self, story))
            task.body = str(doc)

    def process_issues(self, repo, issues=None):
        """
        Process issues will find all the issues in the repo and label them accordin to the
        detected type (story, or task) add the proper linking of tasks to their parent stories, and
        adds a nice table in the story to list all story tasks.

        The tool, will also generate and commit some reports (in markdown syntax) with milestones, open stories
        assignees and estimates.

        It will also process the todo's comments

        !! prio $prio  ($prio is checked on first 4 letters, e.g. critical, or crit matches same)
        !! p $prio (alias above)

        !! move gig-projects/home (move issue to this project, try to keep milestones, labels, ...)
        """
        if issues is None:
            issues = repo.issues

        stories = self._process_stories(issues)

        issues = sorted(issues, key=lambda i: i.number)

        dev_repo = False
         # Logic after this point is only for home and org repo
        for typ in ['org_', 'proj_']:
            if not repo.name.lower().startswith(typ):
                dev_repo = True
                break

        _ms = [('{m.number}:{m.title}'.format(m=m), m) for m in repo.milestones]
        milestones = collections.OrderedDict(sorted(_ms, key=lambda i: i[1].title))
        report = dict()

        for issue in issues:
            self._process_todos(issue)
            # Logic after this point is only for home and org repo
            if not dev_repo:
                continue

            if self._is_story(issue) and issue.isOpen:
                key = '__no_milestone__'
                if issue.milestone:
                    ms = milestones.get(issue.milestone, None)
                    if ms is not None:
                        key = ms.title

                report.setdefault(key, [])
                report[key].append(issue)

            start = issue.title.partition(":")[0]
            if start not in stories:
                # task that doesn't belong to any story. We skip for now
                # but i believe a different logic should be implemented
                continue

            story = stories[start]
            labels = issue.labels
            labels_dirty = False

            if "type_task" not in labels:
                labels.append("type_task")
                labels_dirty = True

            if self._task_estimate(issue.title) is None:
                if "task_no_estimation" not in labels:
                    labels.append("task_no_estimation")
                    labels_dirty = True
            else:
                # pop label out
                if "task_no_estimation" in labels:
                    labels.remove("task_no_estimation")
                    labels_dirty = True

            if labels_dirty:
                # Only update labels if it was changed.
                self.logger.debug('setting issue label')
                issue.labels = labels

            # create link between story and tasks
            # linking logic
            self._task_link_to_story(story, issue)
            self._story_add_task(story, issue)

        # generate views
        self._generate_views(repo, milestones, issues, report)

    def _generate_views(self, repo, milestones, issues, report):
        # end for
        # process milestones
        def _story_deadline(issue):
            eta, id = self._story_estimate(issue)
            try:
                return j.data.time.getEpochFuture(eta), id
            except:
                pass
            try:
                return j.data.time.any2epoch(eta), id
            except:
                pass

            return 0, id

        def summary(ms):
            issues = report.get(ms, [])
            ts = 0
            for issue in issues:
                eta_stamp, _ = _story_deadline(issue)
                if eta_stamp > ts:
                    ts = eta_stamp

            if ts:
                return j.data.time.epoch2HRDate(ts)
            else:
                return 'N/A'

        def state(s):
            if s == 'verification':
                return ':white_circle: Verification'
            elif s == 'inprogress':
                return ':large_blue_circle: In Progress'
            else:
                return ':red_circle: Open'

        def estimate(issue):
            eta, id = _story_deadline(issue)
            if eta:
                return j.data.time.epoch2HRDate(eta), id
            return None, None

        view = MILESTONE_REPORT_TMP.render(repo=repo, report=report, milestones=milestones,
                                           summary=summary, state=state, estimate=estimate)

        repo.set_file(MILESTONE_REPORT_FILE, view)

        # group per user
        assignees = dict()
        for issue in issues:
            if not issue.assignee or not issue.isOpen:
                continue

            assignees.setdefault(issue.assignee, [])
            assignees[issue.assignee].append(issue)

        # sort the assignees dict.
        assignees = collections.OrderedDict(sorted([(k, v) for k, v in assignees.items()], key=lambda i: i[0]))

        # generate milestone details page
        for key, milestone in milestones.items():
            view = MILESTONE_DETAILS_TEMP.render(repo=repo, key=key, milestone=milestone,
                                                 issues=issues, assignees=assignees, state=state)
            repo.set_file("milestones/%s.md" % key, view)

        # assignee details page
        view = ASSIGNEE_REPORT_TMP.render(repo=repo, assignees=assignees, state=state)
        repo.set_file(ASSIGNEE_REPORT_FILE, view)
