#!/usr/bin/env jspython

# Click library has some problems with python3 when it comes to unicode: http://click.pocoo.org/5/python3/#python3-surrogates
# to fix this we need to set the environ variables to export the locales

import os
from JumpScale import j
import click

os.environ['LC_ALL'] = 'C.UTF-8'
os.environ['LANG'] = 'C.UTF-8'

repo = None


@click.group()
@click.option('--nodebug', default=False, help='disable debug mode', is_flag=True)
def cli(nodebug):
    global repo
    repo = j.atyourservice.get()
    repo.debug = not nodebug


@click.command()
@click.option('--path', '-p', help='path of the new AYS repo you want to create')
def create_repo(path):
    """
    create a new AYS repository
    """
    j.atyourservice.repoCreate(path)


@click.command()
@click.option('--role', '-r', default="", help='optional role for ays instances to init')
@click.option('--instance', '-i', default="", help='optional name of instance')
@click.option('--data', '-d', default="", help='data to populate a specific instance')
def init(role="", instance="", data=""):
    """
==== BASE ====

    when using data the data is passed to the specific instance
    if data used the role & instance needs to be used

    step1:
    init will walk over all existing recipes (ays templates in local context)
    and will see if recipe actions or hrd's changed
    if there is change than all ays instance originating from this recipe's state will be changed
    this will allow the further install action to execute on the change

    if there is change in hrd then:
        - change_hrd_template() on the ays instance actions is called
    if there is change in ine if the actions methods then:
        - change_method() on the ays instance actions is called
    This allows action to manipulate the ays tree as result of change

    step2:
    init will walk over all existing ays instances
    init will detect if instance.hrd got changed
    if change than the change will be marked in the state file

    if change in hrd then
        - change_hrd_instance() will be called on ays instance actions

    REMARK:
    blueprints are no longer processed in init step, use the ays blueprint command

    """
    if data != "" and (role == "" or instance == ""):
        raise j.exceptions.Input("need to specify role & instance to pass data")

    repo.init(role=role, instance=instance, data=data)


@click.command()
@click.option('--name', '-n', default=None, help='name of the actor to update')
def update(name):
    """
    Update actor to a new version.
    Any change detected in the actor will be propagated to the services and processChange method will be
    called all the way from actor to service instances.
    """
    names = []
    if name is None:
        names = repo.templates.keys()
    else:
        names = [name]

    for n in names:
        template = repo.templateGet(name=n)
        try:
            actor = repo.actorGet(name=n)
        except:
            import ipdb
            ipdb.set_trace()

        actor._initFromTemplate(template)


@click.command()
@click.argument('path', default='')
@click.option('--role', '-r', default="", help='optional role for ays instances to init')
@click.option('--instance', '-i', default="", help='optional name of instance')
def blueprint(path, role, instance):
    """
    will process the blueprint(s) pointed to

    it path is directory then all blueprints in directory will be processed (when not starting with _)
    if is file than only that 1 file

    if path=="" then blueprints found in $aysdir/blueprints will be processed

    if role & instance specified then only the ays instances with specified role/instance will be processed
    """
    repo.blueprintExecute(role=role, instance=instance, path=path)


@click.command()
@click.argument('servicekey')
def build(servicekey):
    """
    builds specific service
    """
    repo.get(servicekey)


@click.command()
def showactions():
    """
    shows all services with relevant actions
    """
    for service in repo.services:
        print("%s" % service)
        for action, state in service.model.actionsState.items():
            print("- %-20s" % action)


def _do(action, role, instance, force, producerroles, args, ask, debug, profile):
    data = {}
    if args is not None:
        if j.sal.fs.exists(args):
            # args is the path to a file
            ext = j.sal.fs.getFileExtension(args)
            if ext in ['yaml', 'yml']:
                data = j.data.serializer.yaml.load(args)
            elif ext in ['toml']:
                data = j.data.serializer.toml.load(args)
            else:
                data = j.data.serializer.json.load(args)
        else:
            obj = j.data.tags.getObject(tagstring=args)
            data = obj.getDict()

    run = repo.runGet(role=role, instance=instance, action=action, force=force, producerRoles=producerroles, debug=debug, profile=profile, data=data)
    if len(run.steps) <= 0:
        print("Nothing to do.")
        return
    else:
        print(run)
    if ask:
        resp = j.tools.console.askYesNo('Do you want to execute this run ?')
        if resp is False:
            return
    run.execute()


@click.command()
@click.argument('action')
@click.option('--role', '-r', default="", help='optional role for ays instances execute an action on')
@click.option('--instance', '-i', default="", help='optional name of instance')
@click.option('--force', default=False, is_flag=True, help='force execution even if no change')
@click.option('--producerroles', '-p', default="*", help='roles of producers which will be taken into consideration, if * all')
@click.option('--args', default=None, help='argument to pass to the run. Can be a list of tags e.g: "key:value key:value" \
or a path to a file containing the argument. Format of the file can be json, yaml, toml. format is detected using file extension. default format is json')
@click.option('--ask', default=True, is_flag=True, help='ask before confirmation before executing')
@click.option('--debug', default=False, is_flag=True, help='enable debug in jobs')
@click.option('--profile', default=False, is_flag=True, help='enable profiling of the jobs')
def do(action, role, instance, force, producerroles, args, ask, debug, profile):
    """
    call an action (which is a method in the action file e.g. start/stop/export/...)
    """
    _do(action=action, role=role, instance=instance, force=force, producerroles=producerroles, ask=ask, debug=debug, profile=profile, args=args)


@click.command()
@click.option('--role', '-r', default="", help='optional role for ays instances execute an action on')
@click.option('--instance', '-i', default="", help='optional name of instance')
@click.option('--force', default=False, is_flag=True, help='if True then will ignore state of service action.')
@click.option('--producerroles', '-p', default="*", help='roles of producers which will be taken into consideration, if * all')
@click.option('--args', default=None, help='argument to pass to the run. Can be a list of tags e.g: "key:value key:value" \
or a path to a file containing the argument. Format of the file can be json, yaml, toml. format is detected using file extension. default format is json')
@click.option('--ask', default=True, is_flag=True, help='ask before confirmation before executing')
@click.option('--debug', default=False, is_flag=True, help='enable debug in jobs')
@click.option('--profile', default=False, is_flag=True, help='enable profiling of the jobs')
def install(role, instance, force, producerroles, ask, args, debug, profile):
    """
    alias for 'ays do install'
    make it reality
    if you want more finegrained controle please use the do cmd
    """
    _do(action='install', role=role, instance=instance, force=force, producerroles=producerroles, ask=ask, debug=debug, profile=profile, args=args)


@click.command()
@click.argument('action')
@click.option('--role', '-r', default="", help='optional role for ays instances execute an action on')
@click.option('--instance', '-i', default="", help='optional name of instance')
@click.option('--force', default=False, is_flag=True, help='if True then will ignore state of service action.')
@click.option('--producerroles', default="*", help='roles of producers which will be taken into consideration, if * all')
def simulate(action, role="", instance="", force=False, producerroles="*"):
    """
    is like do only does not execute it,
    is ideal to figure out what would happen if you run a certain action
    """
    run = repo.runGet(role=role, instance=instance, action=action,
                      force=force, producerRoles=producerroles, simulate=True)
    print(run)


@click.command()
@click.argument('action')
@click.option('--state', default="DO", help='state to set')
@click.option('--role', default="", help='optional role for ays instances execute an action on')
@click.option('--instance', default="", help='optional name of instance')
@click.option('--force', default=False, is_flag=True, help='if True then will ignore state of service action.')
@click.option('--producerroles', default="", help='roles of producers which will be taken into consideration, if empty then none')
def setstate(action, state="DO", role="", instance="", force=False, producerroles=""):
    """
    be careful what you do with this command
    this sets the state of an ays instance manually
    """
    repo.setState(actions=[action], role=role, instance=instance, state=state)
    run = repo.runGet(role=role, instance=instance, action=action, force=False, producerRoles=producerroles)
    print(run)


@click.command()
@click.option('--printonly', default=False, is_flag=True, help='if set will not really execute, only show what would have been done')
def uninstall(printonly):
    """
    do uninstall
    """
    repo.uninstall(printonly=printonly)


@click.command()
@click.argument('role')
@click.argument('instance')
def show(role, instance):
    '''
    show information about a service
    '''
    service = repo.serviceGet(role=role, instance=instance)
    print("Service: %s" % service)
    print("\nInstance data:")
    instance_data = service.model.data.to_dict()
    for k in sorted(instance_data):
        print("- %s : %s" % (k, instance_data[k]))

    print("\nProducers:")
    service.printProducersRecursive()

    print("\nRecurring actions:")
    for name, model in service.model.actionsRecurring.items():
        print("%s: period:%5s lastRun:%s " % (name, j.data.time.getSecondsInHR(model.period), j.data.time.epoch2HRDateTime(model.lastRun)))

    print("\nEvent actions:")
    for name, model in service.model.actionsEvent.items():
        print("%s: event:%s lastRun:%s " % (name, model.event, j.data.time.epoch2HRDateTime(model.lastRun)))


@click.command()
@click.argument('role')
@click.argument('instance')
def showproducers(role, instance):
    '''
    find the producers for this service & show
    '''
    print("producers:")
    ays = repo.serviceGet(role=role, instance=instance)
    ays.printProducersRecursive()


@click.command()
@click.argument('role')
@click.argument('instance')
def showparents(role, instance):
    """
    Display the list of parent of a specific service instance.
    """
    service = repo.serviceGet(role, instance)
    out = "parents:\n"
    for parent in service.parents:
        out += "- %s\n" % parent
    print(out)


@click.command()
@click.option('--role', '-r', default='')
@click.option('--instance', '-i', default='')
def list(role, instance):
    """
    The list command lists all service instances with specific role and instance name.
    """
    print("Installed services:")
    print("-------------------")
    services = repo.servicesFind(actor="%s.*" % role, name=instance)
    for s in sorted(services, key=lambda service: service.model.role):
        print("%s!%s" % (s.model.role, s.model.dbobj.name))


@click.command()
def destroy():
    """
    reset in current ays repo all services & recipe's in current repo (DANGEROUS)
    all instances will be lost !!!

    make sure to do a commit before you do a distroy, this will give you a chance to roll back.
    """
    repo.destroy(False)
    j.application.reset()


@click.command()
@click.argument('cmd', default='doall')
@click.option('--name', '-n', help="Name of test.", default='fake_IT_env')
@click.option('--message', '-m', help="Message as used in e.g. pull/push.", default='unknown')
def test(cmd, name, message):
    """
    there is a test suite for ays, this command allows to control the test suite

    cmds are
     - doall : execute all tests
     - push : push modified tests to the repo
     - pull : get the repo with the tests
    """
    tester = j.repo.getTester(name)
    if cmd == "doall":
        tester.doall()
    elif cmd == "push":
        tester.gitpush(message=message)
    elif cmd == "pull":
        tester.gitpull(message=message)


@click.command()
@click.option('--branch', '-b', help="Name of branch, can be used in commit/push request to do change mgmt.", default='master')
@click.option('--message', '-m', help="Message as used in e.g. pull/push.", default='')
@click.option('--push', '-p', default=False, is_flag=True, help='if True then will push changes to git repo.')
def commit(message, branch="master", push=False):
    """
    commit the changes in the ays repo to git, can optionally push.
    this is very important because it allows you to see change in ays repo.
    """
    repo.commit(message, branch, push=push)


@click.command()
@click.option('--branch', '-b', help="Name of branch, can be used in pull request to do change mgmt.", default='master')
def update_md(branch="master"):
    """
    update the metdata for the templates as well as the current ays repo
    """
    repo.update(branch=branch)


@click.command()
@click.option('--runid', default=None)
@click.option('--list', is_flag=True, help='list all runid')
def runinfo(runid, list):
    """
    print info about run, if not specified will be latest run
    """
    if list:
        print("Run IDs:")
        for i, key in enumerate(j.core.jobcontroller.db.run.list()):
            print("%d - %s" % (i + 1, key))
        return

    if runid is None:
        runid = j.core.jobcontroller.db.run.list()[-1]
    run = repo.runGet(key=runid)
    print(run)


@click.command()
@click.option('--role', default="", help='optional role for ays instances execute an action on')
@click.option('--instance', default="", help='optional name of instance')
def state(role='', instance=''):
    """
    Print the state of the selected services. If not role or instances specified, all services from the repository are selected
    """
    services = repo.servicesFind(name=instance, actor='%s.*' % role)
    services = sorted(services, key=lambda s: s.model.dbobj.actorName)
    for service in services:
        print('State of service : %s!%s' % (service.model.dbobj.actorName, service.model.dbobj.name))
        for actionName, state in service.model.actionsState.items():
            print("\t%-25s : %s" % (actionName, state))


@click.command()
@click.option('--role', '-r', default="", help='optional role for ays instances you want to delete')
@click.option('--instance', '-i', default="", help='optional name of instance')
@click.option('--ask', default=True, is_flag=True, help='ask confirmation before delete services')
def delete(role, instance, ask):
    """
    Delete a service and all it's children
    Be carefull with this action, there is no come back once a service is deleted.
    """
    services = repo.servicesFind(name=instance, actor='%s.*' % role)
    services = sorted(services, key=lambda s: s.model.dbobj.actorName)

    print("Services selected for deletion:")
    for service in services:
        print(service)

    if ask:
        resp = j.tools.console.askYesNo('\nAre you sure you want to delete ?')
        if resp is False:
            return

    for service in services:
        print('delete %s' % service)
        service.delete()


@click.command()
@click.option('--conf', '-c', default='/optvar/cfg/ays/ays.conf', help='path to AYS configuration file')
def start(conf):
    from JumpScale.baselib.atyourservice81.AtYourServiceDaemon import Server
    server = Server(conf)
    server.start()

cli.add_command(create_repo)
cli.add_command(runinfo)
cli.add_command(simulate)
cli.add_command(test)
cli.add_command(setstate)
cli.add_command(commit)
cli.add_command(update_md)
cli.add_command(blueprint)
# cli.add_command(new)
cli.add_command(destroy)
cli.add_command(init)
cli.add_command(update)
cli.add_command(install)
cli.add_command(uninstall)
cli.add_command(do)
cli.add_command(show)
cli.add_command(showproducers)
cli.add_command(showparents)
cli.add_command(showactions)
cli.add_command(list)
cli.add_command(state)
cli.add_command(delete)
cli.add_command(start)

if __name__ == '__main__':
    cli()
