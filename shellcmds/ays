#!/usr/bin/env jspython

# Click library has some problems with python3 when it comes to unicode: http://click.pocoo.org/5/python3/#python3-surrogates
# to fix this we need to set the environ variables to export the locales

from JumpScale import j
import os
import io
import time
import click
from http import HTTPStatus

os.environ['LC_ALL'] = 'C.UTF-8'
os.environ['LANG'] = 'C.UTF-8'

repo = None
ayscl = j.clients.atyourservice.get()


def _current_repo_name():
    return j.sal.fs.getBaseName(j.sal.fs.getcwd())


def _extract_error(resp):
    if resp.headers['Content-type'] == 'application/json':
        content = resp.json()
        return content.get('error', resp.text)
    return resp.text


def print_date(epoch):
    if epoch == 0:
        return "never"
    return j.data.time.epoch2HRDateTime(epoch)

# main CLI


@click.group()
def cli():
    pass


# AYS repository related group of commands
@cli.group()
def repo():
    """
    Group of commands about AYS repositories
    """
    pass


@repo.command()
@click.option('--path', '-p', default=None, help='path of the new AYS repo you want to create')
@click.option('--git', '-g', default=None, help='URL of the git repository to attach to this AYS repository')
def create(path, git):
    """
    create a new AYS repository
    """
    if git is None:
        print("you have to specify an gi repository using --git")
        return

    if path is None:
        path = j.sal.fs.getcwd()

    data = j.data.serializer.json.dumps({'name': j.sal.fs.getBaseName(path), 'git_url': git})
    resp = ayscl.api.ays.createRepository(data=data)

    if resp.status_code == HTTPStatus.CREATED:
        print("AYS repository created at {}".format(resp.json()['path']))
    else:
        print("Error during creation of the repository: {}".format(_extract_error(resp)))


@repo.command()
def list():
    """
    List all known repositories
    """
    print("AYS Repositories: ")

    resp = ayscl.api.ays.listRepositories()
    if resp.status_code == HTTPStatus.OK:
        repos = resp.json()
        for repo in sorted(repos, key=lambda r: r['name']):
            print(repo['path'])
    else:
        print("Error during listing of the repositories: {}".format(_extract_error(resp)))


@repo.command()
def destroy():
    """
    reset all services & recipe's in current repo (DANGEROUS)
    all instances will be lost !!!

    make sure to do a commit before you do a distroy, this will give you a chance to roll back.
    """
    resp = ayscl.api.ays.deleteRepository(repository=_current_repo_name())
    if resp.status_code == HTTPStatus.NO_CONTENT:
        print("repository destroyed")
    else:
        print("Error while destroying repository: {}".format(_extract_error(resp)))


# AYS service related group of commands
@cli.group()
def service():
    """
    Group of commands about services
    """
    pass


@service.command()
@click.option('--role', '-r', default='')
@click.option('--name', '-n', default='')
def list(role, name):
    """
    The list command lists all service instances with specific role and instance name.
    """
    resp = ayscl.api.ays.listServices(_current_repo_name())
    if resp.status_code == HTTPStatus.OK:
        services = resp.json()
        print("Installed services:")
        print("-------------------")
        for s in sorted(services, key=lambda service: '{role}!{name}'.format(**service)):
            print("%s!%s" % (s['role'], s['name']))
    else:
        print("Error while listing services: {}".format(_extract_error(resp)))


@service.command()
@click.option('--role', '-r', default='')
@click.option('--name', '-n', default='')
# @click.option('--deep', default=False, is_flag=True, help='show producers and consumers recursivlely')
def show(role, name):
    '''
    show information about a service
    '''
    def get_service(role, name):
        resp = ayscl.api.ays.getServiceByName(role=role, name=name, repository=_current_repo_name())
        if resp.status_code != HTTPStatus.OK:
            print("Error while getting service: {}".format(_extract_error(resp)))
            return
        return resp.json()

    resp = ayscl.api.ays.listServices(_current_repo_name())
    if resp.status_code != HTTPStatus.OK:
        print("Error while listing services: {}".format(_extract_error(resp)))
        return

    services = resp.json()
    for service in services:
        if role and service['role'] != role:
            continue
        if name and service['name'] != name:
            continue

        service = get_service(role=service['role'], name=service['name'])
        print('\n')
        print('---------------------------------------------------')
        print("Service: %s - Role: %s" % (service['name'], service['role']))
        color = 'red' if service['state'] == 'error' else 'green'
        print(click.style("state : {}".format(service['state']), fg=color))
        print("key : {}".format(service['key']))
        print("\nInstance data:", end='')
        instance_data = service['data']
        if not instance_data:
            print(" None")
        else:
            print('')
            for k in sorted(instance_data):
                print("- %s : %s" % (k, instance_data[k]))

        print("\nParent:", end='')
        if not service['parent']:
            print(' None')
        else:
            print('')
            print("{role}!{name}".format(**service['parent']))

        print("\nChildren:", end='')
        if len(service['children']) <= 0:
            print(' None')
        else:
            print("")
            for child in service['children']:
                print("{role}!{name}".format(**child))

        print("\nProducers:", end='')
        if not service['producers']:
            print(' None')
        else:
            print('')
            for producer in service['producers']:
                print("{role}!{name}".format(**producer))

        print("\nConsumers:", end='')
        if not service['consumers']:
            print(' None')
        else:
            print('')
            for producer in service['consumers']:
                print("{role}!{name}".format(**producer))

        print("\nRecurring actions:", end='')
        have_reccuring = False
        for action in service['actions']:
            if action['recurring'] is None:
                continue
            print('')
            print("%s: period:%5s last run:%s " % (action['name'], j.data.time.getSecondsInHR(
                action['recurring']['period']), print_date(action['recurring']['last_run'])))
            have_reccuring = True
        if not have_reccuring:
            print(" None")

        print("\nEvent filters:", end='')
        if not service['events']:
            print(' None')
        else:
            print('')
            for event_filter in service['events']:
                print('- actions: %s' % ','.join(event_filter['actions']))
                print('  command: %s' % event_filter['command'])
                print('  channel: %s' % event_filter['channel'])
                print('  tags: %s' % ','.join(event_filter['tags']))


@service.command()
@click.option('--role', '-r', default="", help='optional role of the service')
@click.option('--name', '-n', default="", help='optional name of the service')
def state(role, name):
    """
    Print the state of the selected services. If not role or instances specified, all services from the repository are selected
    """
    resp = ayscl.api.ays.listServices(_current_repo_name())
    if resp.status_code != HTTPStatus.OK:
        print("Error while listing services: {}".format(_extract_error(resp)))
        return

    services = resp.json()
    services = sorted(services, key=lambda s: s['role'])
    for service in services:
        if role and service['role'] != role:
            continue
        if name and service['name'] != name:
            continue

        print('State of service : %s!%s' % (service['role'], service['name']))
        for action in service['actions']:
            print("\t%-25s : %s" % (action['name'], action['state']))


@service.command()
@click.option('--role', '-r', default="", help='optional role for the service you want to delete')
@click.option('--name', '-n', default="", help='optional name of the service')
@click.option('--ask', default=True, is_flag=True, help='ask confirmation before delete services')
def delete(role, name, ask):
    """
    Delete a service and all its children
    Be carefull with this action, there is no come back once a service is deleted.
    """

    def get_service(role, name):
        resp = ayscl.api.ays.getServiceByName(role=role, name=name, repository=_current_repo_name())
        if resp.status_code != HTTPStatus.OK:
            print("Error while getting service: {}".format(_extract_error(resp)))
            return
        return resp.json()

    resp = ayscl.api.ays.listServices(_current_repo_name())
    if resp.status_code != HTTPStatus.OK:
        print("Error while listing services: {}".format(_extract_error(resp)))
        return

    filterd = []
    for service in resp.json():
        if role and service['role'] != role:
            continue
        if name and service['name'] != name:
            continue
        filterd.append(service)

    services = sorted(filterd, key=lambda s: s['role'])

    print("Services selected for deletion:")
    for service in services:
        service = get_service(role=service['role'], name=service['name'])

        print("- {role}!{name}".format(**service))
        if service['children']:
            print('  child that will also be deleted:')
            if service['children']:
                for child in service['children']:
                    print("  - {role}!{name}".format(**child))
            else:
                print("   None")

    if ask:
        resp = j.tools.console.askYesNo('\nAre you sure you want to delete ?')
        if resp is False:
            return

    for service in services:
        resp = ayscl.api.ays.deleteServiceByName(name=service['name'], role=service[
                                                 'role'], repository=_current_repo_name())
        if resp.status_code == HTTPStatus.NO_CONTENT:
            print('service {role}!{name} deleted'.format(**service))
        else:
            print("error during deletion of service {role}!{name}: {error}".format(
                **service, error=_extract_error(resp)))


@cli.group()
def actor():
    """
    Group of commands about actors
    """


@actor.command()
def list():
    """
    list all actor of the repository
    """
    resp = ayscl.api.ays.listActors(repository=_current_repo_name())
    if resp.status_code == HTTPStatus.OK:
        print("Installed actors:")
        print("-------------------")

        for actor in sorted(resp.json(), key=lambda x: x['name']):
            print("{name}".format(**actor))
    else:
        print("error during listing of actors: {}".format(_extract_error(resp)))


@actor.command()
@click.option('--name', '-n', default=None, help='name of the actor to update')
def update(name):
    """
    Update actor to a new version.
    Any change detected in the actor will be propagated to the services and processChange method will be
    called all the way from actor to service instances.
    """
    names = []
    if name is None:
        resp = ayscl.api.ays.listActors(repository=_current_repo_name())
        if resp.status_code == HTTPStatus.OK:
            names = [a['name'] for a in resp.json()]
        else:
            print("error during listing of actors: {}".format(_extract_error(resp)))
            return
    else:
        names = [name]

    for name in names:
        resp = ayscl.api.ays.updateActor(data='', name=name, repository=_current_repo_name())
        if resp.status_code == HTTPStatus.OK:
            print("actor {} updated".format(name))
        else:
            print("error during update of actor {}: {}".format(name, _extract_error(resp)))
            return


@cli.group()
def template():
    """
    Group of commands about actor templates
    """


@template.command()
def list():
    resp = ayscl.api.ays.listTemplates(repository=_current_repo_name())
    if resp.status_code != HTTPStatus.OK:
        print("error during listing of templates: {}".format(_extract_error(resp)))
        return

    for template in sorted(resp.json(),  key=lambda x: x['name']):
        print("{name}".format(**template))


@cli.group()
def run():
    """
    Group of commands about runs
    """


def _print_run(run, logs=False):
    def format_log(log):
        return " {datetime} {category}: {log}\n".format(**log, datetime=print_date(log['epoch']))

    out = io.StringIO()
    out.write(click.style("RUN:{}\n".format(run['key']), fg='green', underline=True))
    # out.write(click.style("-------\n", fg='green'))
    for step in run['steps']:
        # out.write(click.style("## step:{}\n\n".format(step['number']), fg='green'))
        out.write(click.style("step:{number} ({state})\n".format(**step), fg='green', underline=True))
        for job in step['jobs']:
            out.write("- {actor_name:25} {service_name:30} | {action_name:15} ({state})\n".format(**job))
            if logs:
                out.write(click.style("\tlogs:", fg='blue'))
                if len(job['logs']) <= 0:
                    out.write("  none\n")
                else:
                    out.write("\n")

                # import ipdb; ipdb.set_trace()
                for log in job['logs']:
                    if log['log']:
                        out.write(j.data.text.indent(format_log(log) + '\n', nspaces=8))
    print(out.getvalue())


@run.command()
@click.option('--ask', default=True, is_flag=True, help='ask before confirmation before executing')
@click.option('--force', default=False, is_flag=True, help='force execution even if no change')
@click.option('--debug', default=False, is_flag=True, help='enable debug in jobs')
@click.option('--profile', default=False, is_flag=True, help='enable profiling of the jobs')
@click.option('--follow', '-f', is_flag=True, help='follow run execution')
def create(ask, force, debug, profile, follow):
    """
    Look for all action with a state 'schedule', 'changed' or 'error' and create a run.
    A run is an collection of actions that will be run on the repository.
    """
    print("Creation of the run...")
    resp = ayscl.api.ays.createRun(data=None, repository=_current_repo_name(), query_params={'simulate': True})
    if resp.status_code != HTTPStatus.OK:
        print("Error during creation of the run: {}".format(_extract_error(resp)))
        return

    run = resp.json()
    if len(run['steps']) <= 0:
        print("Nothing to do.")
        return

    _print_run(run)

    if ask:
        resp = j.tools.console.askYesNo('Do you want to execute this run ?', True)
        if resp is False:
            return

    resp = ayscl.api.ays.executeRun(data=None, aysrun=run['key'], repository=_current_repo_name())
    if resp.status_code != HTTPStatus.OK:
        print("error during execution of the run: {}".format(_extract_error(resp)))
        return

    print("execution of the run started: {}".format(run['key']))
    if follow:
        running = True
        while running:
            resp = ayscl.api.ays.getRun(aysrun=run['key'], repository=_current_repo_name())
            if resp.status_code != HTTPStatus.OK:
                print("Error during retreive of the run {}: {}".format(key, _extract_error(resp)))
                return

            run = resp.json()
            j.tools.console.cls()
            print("Current state of the run:\n")
            _print_run(run)
            running = False
            for step in resp.json()['steps']:
                for job in step['jobs']:
                    if job['state'] == 'running':
                        running = True
            if running:
                time.sleep(2)


@run.command()
def list():
    resp = ayscl.api.ays.listRuns(repository=_current_repo_name())
    if resp.status_code != HTTPStatus.OK:
        print("Error during listing of the runs: {}".format(_extract_error(resp)))
        return
    runs = resp.json()
    runs = sorted(runs, key=lambda x: x['epoch'])
    for run in runs:
        print("run :{date} {key} ({state})".format(**run, date=print_date(run['epoch'])))


@run.command()
@click.option('--key', '-k', default=None, help='key of the run to show')
@click.option('--logs', '-l', default=False, is_flag=True, help='show logs of the jobs')
def show(key, logs):
    if key is None:
        resp = ayscl.api.ays.listRuns(repository=_current_repo_name())
        if resp.status_code != HTTPStatus.OK:
            print("Error during listing of the runs: {}".format(_extract_error(resp)))
            return
        runs = resp.json()
        runs = sorted(runs, key=lambda x: x['epoch'])
        key = runs[-1]['key']

    resp = ayscl.api.ays.getRun(aysrun=key, repository=_current_repo_name())
    if resp.status_code != HTTPStatus.OK:
        print("Error during retreive of the run {}: {}".format(key, _extract_error(resp)))
        return

    _print_run(resp.json(), logs=logs)


@cli.command()
def start():
    """
    start an ays service in tmux
    """
    j.atyourservice.start()
# AYS service related group of commands


@cli.command()
@click.argument('name', default='')
def blueprint(name):
    """
    will process the blueprint(s) pointed by name
    if name is empty    then all blueprints found in $aysdir/blueprints will be processed
    """
    if name == '':
        resp = ayscl.api.ays.listBlueprints(_current_repo_name())
        if resp.status_code != HTTPStatus.OK:
            print("error during listing of blueptins: {}".format(_extract_error(resp)))
            return

        blueprints = resp.json()
        names = [bp['name'] for bp in blueprints]
    else:
        names = [name]

    for name in sorted(names):
        resp = ayscl.api.ays.executeBlueprint(data=None, blueprint=name, repository=_current_repo_name())
        if resp.status_code == HTTPStatus.OK:
            print("blueprint {} executed".format(name))
        else:
            print('error during execution of the blueprint {}: {}'.format(name, _extract_error(resp)))
            return

if __name__ == '__main__':
    cli()
