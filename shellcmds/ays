#!/usr/bin/env jspython

# Click library has some problems with python3 when it comes to unicode: http://click.pocoo.org/5/python3/#python3-surrogates
# to fix this we need to set the environ varialbes to export the locales

import os
os.environ['LC_ALL'] = 'C.UTF-8'
os.environ['LANG'] = 'C.UTF-8'

from JumpScale import j

import click

cwd = None
atyourservice = None

@click.group()
@click.option('--nodebug', default=False, help='disable debug mode', is_flag=True)
def cli(nodebug):
    global cwd, atyourservice
    cwd = j.sal.fs.getcwd()
    atyourservice = j.atyourservice.get(j.sal.fs.getBaseName(cwd), cwd)
    atyourservice.debug = not nodebug

# @click.command()
# @click.argument('name')
# @click.argument('instance')
# @click.option('--count', default=1, help='number of instances you want to create, default is 1')
# @click.option('--domain', default="", help='optional domain of ays')
# @click.option('--version', default="", help='optional version of ays')
# def new(name,instance,count=1,domain="",version=""):
#     """
#     @arg name: name of ays template to use
#     @arg instance: the name for the instance
#     """
#     from ptpython.repl import embed
#     print ("DEBUG NOW new")
#     embed(globals(), locals())

#     click.echo('new')


@click.command()
@click.option('--role', '-r', default="", help='optional role for ays instances to init')
@click.option('--instance', '-i', default="", help='optional name of instance')
@click.option('--data', '-d', default="", help='data to populate a specific instance')
def init(role="", instance="", data=""):
    """
==== BASE ====

    when using data the data is passed to the specific instance
    if data used the role & instance needs to be used

    step1:
    init will walk over all existing recipes (ays templates in local context)
    and will see if recipe actions or hrd's changed
    if there is change than all ays instance originating from this recipe's state will be changed
    this will allow the further install action to execute on the change

    if there is change in hrd then:
        - change_hrd_template() on the ays instance actions is called
    if there is change in ine if the actions methods then:
        - change_method() on the ays instance actions is called
    This allows action to manipulate the ays tree as result of change

    step2:
    init will walk over all existing ays instances
    init will detect if instance.hrd got changed
    if change than the change will be marked in the state file

    if change in hrd then
        - change_hrd_instance() will be called on ays instance actions

    REMARK:
    blueprints are no longer processed in init step, use the ays blueprint command

    """
    if data != "" and (role == "" or instance == ""):
        raise j.exceptions.Input("need to specify role & instance to pass data")

    atyourservice.init(role=role, instance=instance, data=data)


@click.command()
@click.argument('path', default='')
@click.option('--role', '-r', default="", help='optional role for ays instances to init')
@click.option('--instance', '-i', default="", help='optional name of instance')
def blueprint(path, role, instance):
    """
    will process the blueprint(s) pointed to

    it path is directory then all blueprints in directory will be processed (when not starting with _)
    if is file than only that 1 file

    if path=="" then blueprints found in $aysdir/blueprints will be processed

    if role & instance specified then only the ays instances with specified role/instance will be processed
    """
    atyourservice.execute_blueprint(role=role, instance=instance, path=path)


@click.command()
@click.argument('servicekey')
def build(servicekey):
    """
    builds specific service
    """
    atyourservice.get(servicekey)


@click.command()
def showactions():
    """
    shows all services with relevant actions
    """
    for key, service in atyourservice.services.items():
        print ("%s" % service)
        for key, action in service.action_methods.items():
            print ("- %-20s %s" % (key, action))


# @click.command()
# @click.option('--ask', default=False, is_flag=True, help='ask on which service to execute the action')
# def apply(printonly=False, all=False, ask=False):
#     """
#     """
#     allservices = all
#     atyourservice.apply(printonly=printonly)


@click.command()
@click.argument('action')
@click.option('--role', '-r', default="", help='optional role for ays instances execute an action on')
@click.option('--instance', '-i', default="", help='optional name of instance')
@click.option('--force', default=False, is_flag=True, help='force execution even if no change')
@click.option('--producerroles', default="*", help='roles of producers which will be taken into consideration, if * all')
@click.option('--ask', default=False, is_flag=True, help='ask on which service to execute the action')
def do(action, role="", instance="", force=False, producerroles="*", ask=False):
    """
    call an action (which is a method in the action file e.g. start/stop/export/...)
    """
    # allservices=all
    # atyourservice.do(action,role=role,instance=instance,printonly=printonly, ask=ask,ignorestate=ignorestate,force=force)
    run = atyourservice.getRun(role=role, instance=instance, action=action, force=force, producerRoles=producerroles)
    print(run)
    run.execute()


@click.command()
@click.option('--role', default="", help='optional role for ays instances execute an action on')
@click.option('--instance', default="", help='optional name of instance')
@click.option('--force', default=False, is_flag=True, help='if True then will ignore state of service action.')
@click.option('--producerroles', default="*", help='roles of producers which will be taken into consideration, if * all')
@click.option('--ask', default=False, is_flag=True, help='ask on which service to execute the action')
def install(role="", instance="", force=False, producerroles="*", ask=False):
    """
    make it reality
    if you want more finegrained controle please use the do cmd
    """
    # atyourservice.do("install",role=role,instance=instance,printonly=printonly, ask=ask,ignorestate=ignorestate,force=force)
    run = atyourservice.getRun(role=role, instance=instance, action="install", force=force, producerRoles=producerroles)
    print(run)
    run.execute()


@click.command()
@click.argument('action')
@click.option('--role', default="", help='optional role for ays instances execute an action on')
@click.option('--instance', default="", help='optional name of instance')
@click.option('--force', default=False, is_flag=True, help='if True then will ignore state of service action.')
@click.option('--producerroles', default="*", help='roles of producers which will be taken into consideration, if * all')
def simulate(action, role="", instance="", force=False, producerroles="*"):
    """
    is like do only does not execute it,
    is ideal to figure out what would happen if you run a certain action
    """
    run = atyourservice.getRun(role=role, instance=instance, action=action, force=force, producerRoles=producerroles, simulate=True)
    print(run)


@click.command()
@click.argument('action')
@click.option('--state', default="DO", help='state to set')
@click.option('--role', default="", help='optional role for ays instances execute an action on')
@click.option('--instance', default="", help='optional name of instance')
@click.option('--force', default=False, is_flag=True, help='if True then will ignore state of service action.')
@click.option('--producerroles', default="", help='roles of producers which will be taken into consideration, if empty then none')
def setstate(action, state="DO", role="", instance="", force=False, producerroles=""):
    """
    be careful what you do with this command
    this sets the state of an ays instance manually
    """
    atyourservice.setState(actions=[action], role=role, instance=instance, state=state)
    run = atyourservice.getRun(role=role, instance=instance, action=action, force=False, producerRoles=producerroles)
    print(run)


# @click.command()
# @click.option('--printonly', default=False,  is_flag=True,help='if set will not really execute, only show what would have been done')
# def uninstall(printonly=False):
#     """
#     do uninstall
#     """
#     atyourservice.uninstall(printonly=printonly)


@click.command()
@click.argument('role')
@click.argument('instance')
def showproducers(role, instance):
    '''
    find the producers for this service & show
    '''
    print ("producers:")
    ays = atyourservice.getService(role, instance)
    ays.printProducersRecursive()


@click.command()
@click.argument('role')
@click.argument('instance')
def showparents(role, instance):
    ays = atyourservice.getService(role, instance)
    out = "parents:\n"
    for parent in ays.parents:
        out += "- %s\n" % parent
    print (out)


@click.command()
@click.option('--role', '-r', default='')
@click.option('--instance', '-i', default='')
def list(role, instance):
    print("Installed services:")
    services = atyourservice.findServices(role=role, instance=instance)
    for s in sorted(services, key=lambda service: service.role):
        print("%s!%s" % (s.role, s.instance))


@click.command()
@click.option('--action', '-a', default=None)
def printlog(action):
    action_name, out = atyourservice.alog.getActionOuput(action)
    print("Output of last action: %s\n" % action_name)
    print(out)


@click.command()
def destroy():
    """
    reset in current ays repo all services & recipe's in current repo (DANGEROUS)
    all instances will be lost !!!

    make sure to do a commit before you do a distroy, this will give you a chance to roll back.

    """
    j.actions.resetAll()
    atyourservice.destroy(False)
    j.application.reset()


@click.command()
@click.argument('cmd', default='doall')
@click.option('--name', '-n', help="Name of test.", default='fake_IT_env')
@click.option('--message', '-m', help="Message as used in e.g. pull/push.", default='unknown')
def test(cmd, name, message):
    """
    there is a test suite for ays, this command allows to control the test suite

    cmds are
     - doall : execute all tests
     - push : push modified tests to the repo
     - pull : get the repo with the tests
    """
    tester = j.atyourservice.getTester(name)
    if cmd == "doall":
        tester.doall()
    elif cmd == "push":
        tester.gitpush(message=message)
    elif cmd == "pull":
        tester.gitpull(message=message)


@click.command()
@click.option('--branch', '-b', help="Name of branch, can be used in commit/push request to do change mgmt.", default='master')
@click.option('--message', '-m', help="Message as used in e.g. pull/push.", default='')
@click.option('--push', '-p', default=False, is_flag=True, help='if True then will push changes to git repo.')
def commit(message, branch="master", push=False):
    """
    commit the changes in the ays repo to git, can optionally push.
    this is very important because it allows you to see change in ays repo.
    """
    atyourservice.commit(message, branch, push=push)


@click.command()
@click.option('--branch', '-b', help="Name of branch, can be used in pull request to do change mgmt.", default='master')
def update(branch="master"):
    """
    update the metdata for the templates as well as the current ays repo
    """
    atyourservice.update(branch=branch)


@click.command()
@click.argument('runid', default=0)
def runinfo(runid=0):
    """
    print info about run, if not specified will be latest run
    """
    run = atyourservice.getRun(id=runid)
    print(run)


cli.add_command(runinfo)
cli.add_command(simulate)
cli.add_command(test)
cli.add_command(setstate)
cli.add_command(commit)
cli.add_command(update)
cli.add_command(blueprint)
# cli.add_command(new)
cli.add_command(destroy)
cli.add_command(init)
# cli.add_command(apply)
cli.add_command(install)
# cli.add_command(uninstall)
cli.add_command(do)
cli.add_command(showproducers)
cli.add_command(showparents)
cli.add_command(showactions)
cli.add_command(list)
cli.add_command(printlog)
# cli.add_command(debug)

# print (sys.excepthook)

if __name__ == '__main__':
    cli()
    # cli(standalone_mode=False)

# j.application.stop()
# j.logger.enabled = False
